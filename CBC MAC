#include <stdio.h>
#include <string.h>
#include <stdint.h>

// Assume AES encryption is used for the block cipher
// You'll need an AES library for encryption, which is not provided here

void aes_encrypt(const uint8_t *input, const uint8_t *key, uint8_t *output) {
    // This function should perform AES encryption of 'input' using 'key' and store the result in 'output'
    // You need to use a suitable AES library for this purpose
    // This function is not implemented here for simplicity
}

void xor_blocks(const uint8_t *a, const uint8_t *b, uint8_t *result, size_t block_size) {
    for (size_t i = 0; i < block_size; ++i) {
        result[i] = a[i] ^ b[i];
    }
}

void cbc_mac(const uint8_t *message, size_t message_size, const uint8_t *key, uint8_t *mac) {
    const size_t block_size = 16; // Assuming AES block size

    // Padding the message if needed
    size_t padded_size = (message_size % block_size == 0) ? message_size : ((message_size / block_size) + 1) * block_size;
    uint8_t padded_message[padded_size];
    memcpy(padded_message, message, message_size);
    memset(padded_message + message_size, 0, padded_size - message_size);

    // Initialize the MAC as an all-zero block
    uint8_t current_mac[block_size] = {0};

    // Process blocks of the padded message
    for (size_t i = 0; i < padded_size; i += block_size) {
        // XOR the current message block with the current MAC
        uint8_t xor_result[block_size];
        xor_blocks(padded_message + i, current_mac, xor_result, block_size);

        // Encrypt the XOR result using the key
        aes_encrypt(xor_result, key, current_mac);
    }

    // Copy the final MAC to the output
    memcpy(mac, current_mac, block_size);
}

int main() {
    // Example: one-block message X
    uint8_t message[16] = {
        0x45, 0x76, 0x98, 0xAB, 0xCD, 0xEF, 0x12, 0x34,
        0x56, 0x78, 0x90, 0x23, 0x45, 0x67, 0x89, 0x01
    };

    // Example key
    uint8_t key[16] = {
        0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
        0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10
    };

    uint8_t mac[16];

    // Calculate the MAC for the one-block message
    cbc_mac(message, sizeof(message), key, mac);

    printf("MAC for one-block message:\n");
    for (int i = 0; i < 16; i++) {
        printf("%02x ", mac[i]);
    }
    printf("\n");

    // Adversary scenario: knowing the MAC for the two-block message
    uint8_t two_block_message[32];
    memcpy(two_block_message, message, 16);
    xor_blocks(message, mac, two_block_message + 16, 16);

    // Calculate the MAC for the two-block message
    cbc_mac(two_block_message, sizeof(two_block_message), key, mac);

    printf("MAC for two-block message:\n");
    for (int i = 0; i < 16; i++) {
        printf("%02x ", mac[i]);
    }
    printf("\n");

    return 0;
}
